package com.proton.jdbc;

import java.net.URI;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Calendar;
import java.util.Collections;
import java.util.Optional;
import java.util.TimeZone;

import com.proton.client.ProtonColumn;
import com.proton.client.ProtonConfig;
import com.proton.client.ProtonDataType;
import com.proton.client.ProtonValue;
import com.proton.client.ProtonValues;
import com.proton.client.ProtonVersion;
import com.proton.client.data.ProtonSimpleResponse;
import com.proton.jdbc.parser.ProtonSqlStatement;

public interface ProtonConnection extends Connection {
    // The name of the application currently utilizing the connection
    static final String PROP_APPLICATION_NAME = "ApplicationName";
    static final String PROP_CUSTOM_HTTP_HEADERS = "CustomHttpHeaders";
    static final String PROP_CUSTOM_HTTP_PARAMS = "CustomHttpParameters";
    // The name of the user that the application using the connection is performing
    // work for. This may not be the same as the user name that was used in
    // establishing the connection.
    // private static final String PROP_CLIENT_USER = "ClientUser";
    // The hostname of the computer the application using the connection is running
    // on.
    // private static final String PROP_CLIENT_HOST = "ClientHostname";

    @Override
    default ProtonArray createArrayOf(String typeName, Object[] elements) throws SQLException {
        ProtonConfig config = getConfig();
        ProtonColumn column = ProtonColumn.of("", ProtonDataType.array, false,
                ProtonColumn.of("", typeName));
        ProtonValue v = ProtonValues.newValue(config, column).update(elements);
        ProtonResultSet rs = new ProtonResultSet("", "", createStatement(),
                ProtonSimpleResponse.of(config, Collections.singletonList(column),
                        new Object[][] { new Object[] { v.asObject() } }));
        rs.next();
        return new ProtonArray(rs, 1);
    }

    @Override
    default ProtonBlob createBlob() throws SQLException {
        return new ProtonBlob();
    }

    @Override
    default ProtonClob createClob() throws SQLException {
        return new ProtonClob();
    }

    @Override
    default ProtonStruct createStruct(String typeName, Object[] attributes) throws SQLException {
        return new ProtonStruct(typeName, attributes);
    }

    @Override
    default ProtonXml createSQLXML() throws SQLException {
        return new ProtonXml();
    }

    @Override
    default ProtonStatement createStatement() throws SQLException {
        return createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default ProtonStatement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return createStatement(resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    ProtonStatement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
            throws SQLException;

    @Override
    default CallableStatement prepareCall(String sql) throws SQLException {
        return prepareCall(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return prepareCall(sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
            int resultSetHoldability) throws SQLException {
        throw SqlExceptionUtils.unsupportedError("prepareCall not implemented");
    }

    @Override
    default PreparedStatement prepareStatement(String sql) throws SQLException {
        return prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        if (autoGeneratedKeys != Statement.NO_GENERATED_KEYS) {
            // not entirely true, what if the table engine is JDBC?
            throw SqlExceptionUtils.unsupportedError("Only NO_GENERATED_KEYS is supported");
        }

        return prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    @Override
    default PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        // not entirely true, what if the table engine is JDBC?
        throw SqlExceptionUtils.unsupportedError("Proton does not support auto generated keys");
    }

    @Override
    default PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        // not entirely true, what if the table engine is JDBC?
        throw SqlExceptionUtils.unsupportedError("Proton does not support auto generated keys");
    }

    @Override
    default PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
            throws SQLException {
        return prepareStatement(sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    /**
     * Gets configuration tied to this connection.
     *
     * @return non-null configuration
     */
    ProtonConfig getConfig();

    /**
     * Gets current database. {@link #getSchema()} is similar but it will check if
     * connection is closed or not hence may throw {@link SQLException}.
     *
     * @return non-null database name
     */
    String getCurrentDatabase();

    /**
     * Gets current user.
     *
     * @return non-null user name
     */
    String getCurrentUser();

    /**
     * Gets default calendar which can be used to create timestamp.
     *
     * @return non-null calendar
     */
    Calendar getDefaultCalendar();

    /**
     * Gets effective time zone. When
     * {@link com.proton.client.ProtonConfig#isUseServerTimeZone()} returns
     * {@code false},
     * {@link com.proton.client.ProtonConfig#getUseTimeZone()}
     * will be used as effective time zone, which will be used for reading and
     * writing timestamp values.
     *
     * @return effective time zone
     */
    Optional<TimeZone> getEffectiveTimeZone();

    /**
     * Gets cached value of {@code TimeZone.getDefault()}.
     *
     * @return non-null cached JVM time zone
     */
    TimeZone getJvmTimeZone();

    /**
     * Gets server time zone, which is either same as result of
     * {@code select timezone()}, or the overrided value from
     * {@link com.proton.client.ProtonConfig#getServerTimeZone()}.
     *
     * @return non-null server time zone
     */
    TimeZone getServerTimeZone();

    /**
     * Gets server version.
     *
     * @return non-null server version
     */
    ProtonVersion getServerVersion();

    /**
     * Gets URI of the connection.
     *
     * @return URI of the connection
     */
    URI getUri();

    /**
     * Gets JDBC-specific configuration.
     *
     * @return non-null JDBC-specific configuration
     */
    JdbcConfig getJdbcConfig();

    /**
     * Creates a new query ID.
     *
     * @return universal unique query ID
     */
    String newQueryId();

    /**
     * Parses the given sql.
     *
     * @param sql    sql to parse
     * @param config configuration which might be used for parsing, could be null
     * @return non-null parsed sql statements
     */
    ProtonSqlStatement[] parse(String sql, ProtonConfig config);
}
